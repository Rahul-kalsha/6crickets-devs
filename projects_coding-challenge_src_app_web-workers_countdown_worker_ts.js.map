{"version":3,"file":"projects_coding-challenge_src_app_web-workers_countdown_worker_ts.js","mappings":";;;;;;;;;;AAAA;AAEAA,gBAAgB,CAAC,SAAS,EAAE,CAAC;EAAEC;AAAI,CAAE,KAAI;EACvC,MAAMC,cAAc,GAAGD,IAAI,CAAC,CAAC;EAC7B,IAAIE,WAAW,GAAGD,cAAc;EAChC,MAAME,UAAU,GAAGC,WAAW,CAAC,MAAK;IAClC,IAAIF,WAAW,GAAG,CAAC,EAAE;MACnBA,WAAW,EAAE;MACbG,WAAW,CAACH,WAAW,CAAC,CAAC,CAAC;IAC5B,CAAC,MAAM;MACLI,aAAa,CAACH,UAAU,CAAC,CAAC,CAAC;MAC3BE,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACnB;EACF,CAAC,EAAE,IAAI,CAAC;EAER;EACAE,IAAI,CAACR,gBAAgB,CAAC,OAAO,EAAE,MAAK;IAClCO,aAAa,CAACH,UAAU,CAAC;EAC3B,CAAC,CAAC;AACJ,CAAC,CAAC;;;;;;SCnBF;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;;;;;UC5BA;;;;;UCAA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,oJAAoJ;UACpJ;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,IAAI,aAAa;UACjB;UACA;UACA;UACA;UACA;UACA;UACA;;;;;SEzCA;SACA;SACA;SACA","sources":["./projects/coding-challenge/src/app/web-workers/countdown.worker.ts","webpack/bootstrap","webpack/runtime/hasOwnProperty shorthand","webpack/runtime/sharing","webpack/before-startup","webpack/startup","webpack/after-startup"],"sourcesContent":["/// <reference lib=\"webworker\" />\r\n\r\naddEventListener('message', ({ data }) => {\r\n  const initialSeconds = data; // Get the initial seconds from the message\r\n  let secondsLeft = initialSeconds;\r\n  const intervalId = setInterval(() => {\r\n    if (secondsLeft > 0) {\r\n      secondsLeft--;\r\n      postMessage(secondsLeft); // Send the updated seconds back to the main thread\r\n    } else {\r\n      clearInterval(intervalId); // Stop the interval when countdown reaches zero\r\n      postMessage(-1); // Send a signal that the deadline has passed\r\n    }\r\n  }, 1000);\r\n\r\n  // Cleanup function when the worker is terminated\r\n  self.addEventListener('close', () => {\r\n    clearInterval(intervalId);\r\n  });\r\n});\r\n\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// expose the module cache\n__webpack_require__.c = __webpack_module_cache__;\n\n","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.S = {};\nvar initPromises = {};\nvar initTokens = {};\n__webpack_require__.I = (name, initScope) => {\n\tif(!initScope) initScope = [];\n\t// handling circular init calls\n\tvar initToken = initTokens[name];\n\tif(!initToken) initToken = initTokens[name] = {};\n\tif(initScope.indexOf(initToken) >= 0) return;\n\tinitScope.push(initToken);\n\t// only runs once\n\tif(initPromises[name]) return initPromises[name];\n\t// creates a new share scope if needed\n\tif(!__webpack_require__.o(__webpack_require__.S, name)) __webpack_require__.S[name] = {};\n\t// runs all init snippets from all modules reachable\n\tvar scope = __webpack_require__.S[name];\n\tvar warn = (msg) => {\n\t\tif (typeof console !== \"undefined\" && console.warn) console.warn(msg);\n\t};\n\tvar uniqueName = \"codingChallenge\";\n\tvar register = (name, version, factory, eager) => {\n\t\tvar versions = scope[name] = scope[name] || {};\n\t\tvar activeVersion = versions[version];\n\t\tif(!activeVersion || (!activeVersion.loaded && (!eager != !activeVersion.eager ? eager : uniqueName > activeVersion.from))) versions[version] = { get: factory, from: uniqueName, eager: !!eager };\n\t};\n\tvar initExternal = (id) => {\n\t\tvar handleError = (err) => (warn(\"Initialization of sharing external failed: \" + err));\n\t\ttry {\n\t\t\tvar module = __webpack_require__(id);\n\t\t\tif(!module) return;\n\t\t\tvar initFn = (module) => (module && module.init && module.init(__webpack_require__.S[name], initScope))\n\t\t\tif(module.then) return promises.push(module.then(initFn, handleError));\n\t\t\tvar initResult = initFn(module);\n\t\t\tif(initResult && initResult.then) return promises.push(initResult['catch'](handleError));\n\t\t} catch(err) { handleError(err); }\n\t}\n\tvar promises = [];\n\tswitch(name) {\n\t}\n\tif(!promises.length) return initPromises[name] = 1;\n\treturn initPromises[name] = Promise.all(promises).then(() => (initPromises[name] = 1));\n};","","// module cache are used so entry inlining is disabled\n// startup\n// Load entry module and return exports\nvar __webpack_exports__ = __webpack_require__(1614);\n",""],"names":["addEventListener","data","initialSeconds","secondsLeft","intervalId","setInterval","postMessage","clearInterval","self"],"sourceRoot":"webpack:///","x_google_ignoreList":[1,2,3,4,5,6]}